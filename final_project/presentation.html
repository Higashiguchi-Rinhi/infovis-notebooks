<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tan Rinhi">

<title>Final Presentation 10 Jan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="presentation_files/libs/clipboard/clipboard.min.js"></script>
<script src="presentation_files/libs/quarto-html/quarto.js"></script>
<script src="presentation_files/libs/quarto-html/popper.min.js"></script>
<script src="presentation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="presentation_files/libs/quarto-html/anchor.min.js"></script>
<link href="presentation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="presentation_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="presentation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="presentation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="presentation_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#答えたい問い" id="toc-答えたい問い" class="nav-link active" data-scroll-target="#答えたい問い">答えたい問い</a></li>
  <li><a href="#データの概要取得と前処理の方法" id="toc-データの概要取得と前処理の方法" class="nav-link" data-scroll-target="#データの概要取得と前処理の方法">データの概要、取得と前処理の方法</a>
  <ul class="collapse">
  <li><a href="#データの前処理" id="toc-データの前処理" class="nav-link" data-scroll-target="#データの前処理">データの前処理</a>
  <ul class="collapse">
  <li><a href="#データをmerge-変数の解読及び変換" id="toc-データをmerge-変数の解読及び変換" class="nav-link" data-scroll-target="#データをmerge-変数の解読及び変換">データをmerge, 変数の解読及び変換</a></li>
  <li><a href="#曲を分けて曲の中でのメロディーラインをつなげる" id="toc-曲を分けて曲の中でのメロディーラインをつなげる" class="nav-link" data-scroll-target="#曲を分けて曲の中でのメロディーラインをつなげる"><strong>曲を分けて、曲の中でのメロディーラインをつなげる</strong></a></li>
  </ul></li>
  </ul></li>
  <li><a href="#可視化作品と考察" id="toc-可視化作品と考察" class="nav-link" data-scroll-target="#可視化作品と考察">可視化作品と考察</a>
  <ul class="collapse">
  <li><a href="#音価の変化と時間" id="toc-音価の変化と時間" class="nav-link" data-scroll-target="#音価の変化と時間">音価の変化と時間</a></li>
  <li><a href="#音価の変化とその数" id="toc-音価の変化とその数" class="nav-link" data-scroll-target="#音価の変化とその数">音価の変化とその数</a></li>
  <li><a href="#考察" id="toc-考察" class="nav-link" data-scroll-target="#考察">考察</a></li>
  <li><a href="#future-directions" id="toc-future-directions" class="nav-link" data-scroll-target="#future-directions">Future directions</a></li>
  </ul></li>
  <li><a href="#コードへのリンク" id="toc-コードへのリンク" class="nav-link" data-scroll-target="#コードへのリンク">コードへのリンク</a></li>
  </ul>
<div class="quarto-code-links"><h2>Code Links</h2><ul><li><a href="https://github.com/Higashiguchi-Rinhi/infovis-notebooks/blob/658a3842b65907151da01ff55cbed7bbdf30f7b9/final_project/project.ipynb"><i class="bi bi-link-45deg"></i>Code for Analysis</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Presentation 10 Jan</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Tan Rinhi </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="答えたい問い" class="level1">
<h1>答えたい問い</h1>
<p>・世の中のメロディー大体そんなに遠い音に行かないのではないのか、音が移るのには規則があるのではないか。<br>
・音自体がどこに行くのが多いのか、1,2,5音とか<br>
・（時間があれば）楽器によってそれが変わるのか</p>
<p>なお、発表者は趣味で音楽を聴く程度のもので、音楽理論とかは勉強したことがないです。</p>
</section>
<section id="データの概要取得と前処理の方法" class="level1">
<h1>データの概要、取得と前処理の方法</h1>
<p>以下の論文からのデータセットを使用する。</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>John Thickstun, Zaid Harchaoui, &amp; Sham M. Kakade. (2016). MusicNet (1.0) [Data set]. Zenodo. https://doi.org/10.5281/zenodo.5120004</p>
</div>
</div>
</div>
<p>kaggleにあったデータの概要は以下のようになっている。</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>MusicNet is a collection of 330 freely-licensed classical music recordings, together with over 1 million annotated labels indicating the precise time of each note in every recording, the instrument that plays each note, and the note’s position in the metrical structure of the composition. The labels are acquired from musical scores aligned to recordings by dynamic time warping. The labels are verified by trained musicians; a labeling error rate of 4% has been estimated. The MusicNet labels are offered to the machine learning and music communities as a resource for training models and a common benchmark for comparing results.</p>
<p>https://www.kaggle.com/datasets/imsparsh/musicnet-dataset</p>
</div>
</div>
</div>
<p>実際のデータを見てみると</p>
<ol type="1">
<li>作曲家</li>
<li>曲名</li>
<li>楽章番号</li>
<li>アンサンブルの種類(solo, quartet etc.)</li>
<li>楽器</li>
<li>音符</li>
<li>音価</li>
<li>音の開始時間</li>
<li>音の終了時間</li>
</ol>
<p>といった変数があり、今回気になるのは楽曲、楽章番号、音符、音の開始時間です。</p>
<section id="データの前処理" class="level2">
<h2 class="anchored" data-anchor-id="データの前処理">データの前処理</h2>
<section id="データをmerge-変数の解読及び変換" class="level3">
<h3 class="anchored" data-anchor-id="データをmerge-変数の解読及び変換">データをmerge, 変数の解読及び変換</h3>
<p>メタデータと曲ごとのデータがあったので、idを基に両者を合体した。基本的にtidy dataの形になっていた。データの欠測はないことを確認した。</p>
<p>メタデータ上に気になる変数である楽器と音価、が見あたらなかったので、数値として入力されている解読をする。</p>
<p>楽器: <a href="https://music.stackexchange.com/questions/135779/im-having-difficulty-comprehending-the-timing-information-presented-in-the-csv">ここから</a>取得。</p>
<ul>
<li>1 is Piano (4th and 5th staff)</li>
<li>41 is Violin (1st staff)</li>
<li>42 is Viola (2nd staff)</li>
<li>43 is Cello (3rd staff, upper voice)</li>
<li>44 is Double Bass (3rd staff, lower voice)</li>
</ul>
<p>音価: 60がmiddle Cということを実際の譜面を見て確認。この分析では60をC4する。半音あがることで1増え、1オクターブ12音ある。</p>
<p>これを踏まえて0-98の数字を’C’, ‘C#’, ‘D’, ‘D#’, ‘E’, ‘F’, ‘F#’, ‘G’, ‘G#’, ‘A’, ‘A#’, ’B’に対応するものに置き換える。</p>
</section>
<section id="曲を分けて曲の中でのメロディーラインをつなげる" class="level3">
<h3 class="anchored" data-anchor-id="曲を分けて曲の中でのメロディーラインをつなげる"><strong>曲を分けて、曲の中でのメロディーラインをつなげる</strong></h3>
<p>また、メロディーの音の移り変わりを見るにはまず曲ごと、次に複数楽器に演奏されている場合は楽器ごとにデータをgroupingする必要があるのでそちらも処理しました。</p>
<p>データセットでは同時に流れる音が同じ「音の開始時間」の入力として全てデータに入れられているので、まず、ラインを特定する必要がある。</p>
<p>1. Solo pianoなどの楽器が1つしかないもの</p>
<p>2. Piano quintetなどの楽器が複数あるものを分ける</p>
<p>と、前者の方が処理が簡単になり。なお、これらにおいても鍵盤楽器や弦楽器は複数音同時に出るのでそれを分ける方法も考える必要がある</p>
<p>今回のデータセットでは330曲中単音しか吹けない楽器によるSoloに該当するものは1曲だけでした。今回の分析では、BachによるFlute Soloの”Partita in A minor”という曲を分析しました。これでメロディーラインは抽出できました。</p>
</section>
</section>
</section>
<section id="可視化作品と考察" class="level1">
<h1>可視化作品と考察</h1>
<section id="音価の変化と時間" class="level2">
<h2 class="anchored" data-anchor-id="音価の変化と時間">音価の変化と時間</h2>
<div id="fig-1" class="quarto-float quarto-figure quarto-figure-center anchored" height="7in" width="100%">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="notediff_time.html" id="fig-1" style="width:100.0%;height:7in">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1
</figcaption>
</figure>
</div>
<p>データ変数と視覚変数の対応関係</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>データ変数</th>
<th>視覚変数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>音符(12音、名義尺度)</td>
<td>色</td>
</tr>
<tr class="even">
<td>音価の差(連続変数)</td>
<td>y軸上の高さ</td>
</tr>
</tbody>
</table>
<p>これを見るだけでは似たようなトレンドがあるかもしれない、ということしかわからない。</p>
</section>
<section id="音価の変化とその数" class="level2">
<h2 class="anchored" data-anchor-id="音価の変化とその数">音価の変化とその数</h2>
<p>音価の変化とその数を図示。<br>
このとき、音符の情報も色として積み上げ棒グラフに入れる。<br>
+-2の音の差が多いことが分かります。</p>
<div id="fig-2" class="quarto-float quarto-figure quarto-figure-center anchored" height="3in" width="100%">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="notediff_count_all.html" id="fig-2" style="width:100.0%;height:3in">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2
</figcaption>
</figure>
</div>
<table class="caption-top table">
<thead>
<tr class="header">
<th>データ変数</th>
<th>視覚変数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>音符(12音、名義尺度)</td>
<td>色</td>
</tr>
<tr class="even">
<td>音価の差の数(連続変数)</td>
<td>バーグラフの高さ</td>
</tr>
</tbody>
</table>
<p>より詳しく見るために、音程毎の割合を出しました。</p>
<div id="fig-3" class="quarto-float quarto-figure quarto-figure-center anchored" height="5in" width="100%">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="notediff_prop.html" id="fig-3" style="width:100.0%;height:5in">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3
</figcaption>
</figure>
</div>
<table class="caption-top table">
<thead>
<tr class="header">
<th>データ変数</th>
<th>視覚変数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>音符(12音、名義尺度)</td>
<td>色</td>
</tr>
<tr class="even">
<td>音価の差の割合(連続変数)</td>
<td>バーグラフの高さ</td>
</tr>
</tbody>
</table>
</section>
<section id="考察" class="level2">
<h2 class="anchored" data-anchor-id="考察">考察</h2>
<p>A minor scaleにある音はA, B, C, D, E, F, Gでできている。<br>
</p>
<p>Note Intervals:</p>
<ul>
<li>Tonic: A is the 1st note of the A natural minor scale.</li>
<li>Major 2nd: B is the 2nd note of the scale.</li>
<li>Minor 3rd: C is the 3rd note of the scale.</li>
<li>Perfect 4th: D is the 4th note of the scale.</li>
<li>Perfect 5th: E is the 5th note of the scale.</li>
<li>Minor 6th: F is the 6th note of the scale.</li>
<li>Minor 7th: G is the 7th note of the scale.</li>
<li>Perfect 8th: A (one octave higher) is the 8th note of the A natural minor scale.</li>
</ul>
<p><a href="#fig-3" class="quarto-xref">Figure&nbsp;3</a> にあるようにスケール上の音は概ね全体の傾向同様+-2の差のを取るのが多い。一方、そうでない音は特定の音程差しかとらない、つまりA#の場合だと特定の9音にしか行かない。 音楽理論の知識がないので音ごとの分析はできないのですが、面白いと感じたのは絶対に行かない音がほとんどの音ごとにあるということ。例えばFは-1の音は絶対に取らない、など。今回のscaleの1音目であるAでも、+6音の音は取らないです。</p>
<p>Bachはその後のクラシック音楽の基礎を作ったともいえるほどに影響力が大きいとされているので、他の作曲家の曲よりもBachのものを分析できてよかったと思います。また、その後の作曲家に比べて、単純かつ構造がしっかりしているので今回の簡単な分析でも解釈可能?な結果になったのはその影響があるかもしれません。</p>
</section>
<section id="future-directions" class="level2">
<h2 class="anchored" data-anchor-id="future-directions">Future directions</h2>
<p>音の移り替わりなどを見るのに、可能であればinteractiveなもの、<a href="https://www.hooktheory.com/trends#key=A&amp;scale=minor" class="uri">こちらのページ</a> みたいにできたら面白いと思いました。</p>
<iframe width="700" height="500" src="https://www.hooktheory.com/trends#key=A&amp;scale=minor" title="Webpage example"></iframe>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>Kulkarni, S., David, S. U., Lynn, C. W., &amp; Bassett, D. S. (2024). Information content of note transitions in the music of JS Bach. <em>Physical Review Research</em>, 6(1), 013136.</p>
</div>
</div>
</div>
<p>こちらの論文ではBachの楽曲の各音符をノードに、音符間の各遷移をエッジにネットワーク分析していました。このように数学的に構造化できたら音楽も分析できるのかなと感じました。</p>
</section>
</section>
<section id="コードへのリンク" class="level1">
<h1>コードへのリンク</h1>
<p>Github repository link: <a href="https://github.com/Higashiguchi-Rinhi/infovis-notebooks/blob/658a3842b65907151da01ff55cbed7bbdf30f7b9/final_project/project.ipynb" class="uri">https://github.com/Higashiguchi-Rinhi/infovis-notebooks/blob/658a3842b65907151da01ff55cbed7bbdf30f7b9/final_project/project.ipynb</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>